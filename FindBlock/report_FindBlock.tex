\documentclass[12pt,a4paper]{scrartcl}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[rightcaption]{sidecap}
\usepackage{wrapfig}
\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage{multicol}

\begin{document}

\input{title}

\newpage
\section{Постановка задачи.}

Для заданного графа (в том числе и несвязного) $G=(V,E)$ найти все блоки графа.

\section{Описание алгоритма.}

Запустим обход в глубину из произвольной вершины графа,обозначим ее через root (корень). Заметим следующий факт (который несложно доказать):

Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины $u \neq root$. Тогда, если текущее ребро $(u,v)$ таково, что из вершины $v$ и из любого её потомка в дереве обхода в глубину нет обратного ребра в какого-либо предка вершины $u$, то вершина $u$ является точкой сочленения. В противном случае, т.е. если обход в глубину просмотрел все рёбра из вершины v, и не нашёл удовлетворяющего вышеописанным условиям ребра, то вершина $u$ не является точкой сочленения. (В самом деле, мы этим условием проверяем, нет ли другого пути из $u$ в $v$)

Рассмотрим теперь оставшийся случай: $v = root$. Тогда эта вершина является точкой сочленения тогда и только тогда, когда эта вершина имеет более одного сына в дереве обхода в глубину. (В самом деле, это означает, что, пройдя из $root$ по произвольному ребру, мы не смогли обойти весь граф, откуда сразу следует, что $root$ — точка сочленения).

Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми алгоритмом поиска в глубину.

Итак, пусть $visitedVertex[v]$ — это время захода поиска в глубину в вершину u. Теперь введём массив $low[v]$, который и позволит нам отвечать на вышеописанные запросы. Время $low[v]$ равно минимуму из времени захода в саму вершину $visitedVertex[v]$, времён захода в каждую вершину $v$, являющуюся концом некоторого обратного ребра $(u,v)$, а также из всех значений $low[v]$ для каждой вершины $v$, являющейся непосредственным сыном $u$ в дереве поиска:

\[
 low[u] = \min \begin{cases}
                    visitedVertex[u],\\
                    visitedVertex[v]\text{  } \forall (u,v) - \text{обратное ребро}\\
                    low[v]\text{  }  \forall (u,v) - \text{ребро дерева}
                    \end{cases}
\]

Тогда, из вершины $u$ или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын $v$, что $low[v] < visitedVertex[u]$.

Таким образом, если для текущего ребра $(u,v)$ (принадлежащего дереву поиска) выполняется $low[v] \le visitedVertex[u]$, то вершина $u$ является точкой сочленения. Для начальной вершины $u = root$ критерий другой: для этой вершины надо посчитать число непосредственных сыновей в дереве обхода в глубину.

\section{Код программы.}

\input{FindBlock/code}

	\newpage
\section{Тесты.}

\subsection{Пример 1:}
	\begin{figure}[h]
	\begin{multicols}{2}
		\hfill
		\includegraphics[width=70mm]{BiconnectedComponent.png}
		\hfill
		\caption{Грраф из Примера 1}
		\hfill
		\includegraphics[width=70mm]{ex1.png}
		\hfill
		\caption{Результат программы}
	\end{multicols}
\end{figure}

\begin{figure}[h]
	\begin{multicols}{2}
		\hfill
		\includegraphics[width=50mm]{graph2.jpg}
		\hfill
		\caption{Граф из Примера 2}
		\hfill
		\includegraphics[width=70mm]{ex2.png}
		\hfill
		\caption{Результат программы}
	\end{multicols}
\end{figure}

\section{Выводы.}

 Двусвязность графа - очень желательный признак для некоторых приложений. Представим себе, что вершины графа изображают узлы некоторой информационной сети, а ребра соответствуют линиям передачи. Если наш граф двусвязный, то выход из строя отдельного узла w никогда не приведет к потере соединения между любыми двумя узлами, отличными от w. Знание блоков графа также очень важно, если принять во внимание то, что многие графовые задачи, такие как нахождение всех элементарных циклов или установление факта планарности графа (граф называется планарным, если его можно так начертить на плоскости, чтобы никакие два ребра не пересекались), приводят естественным путем к аналогичным задачам для блоков данного графа.
\end{document}
